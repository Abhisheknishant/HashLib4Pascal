unit HlpRIPEMD320;

{$I ..\Include\HashLib.inc}

interface

uses
{$IFDEF DELPHI2010}
  SysUtils, // to get rid of compiler hint "not inlined" on Delphi 2010.
{$ENDIF DELPHI2010}
  HlpMDBase,
{$IFDEF DELPHI}
  HlpBitConverter,
{$ENDIF DELPHI}
  HlpBits,
  HlpConverters,
  HlpIHashInfo;

type
  TRIPEMD320 = class sealed(TMDBase, ITransformBlock)

  strict protected
    procedure TransformBlock(a_data: PByte; a_data_length: Int32;
      a_index: Int32); override;

  public
    constructor Create();
    procedure Initialize(); override;

  end;

implementation

{ TRIPEMD320 }

constructor TRIPEMD320.Create;
begin
  Inherited Create(10, 40);
end;

procedure TRIPEMD320.Initialize;
begin
  Fptr_Fm_state[4] := $C3D2E1F0;
  Fptr_Fm_state[5] := $76543210;
  Fptr_Fm_state[6] := $FEDCBA98;
  Fptr_Fm_state[7] := $89ABCDEF;
  Fptr_Fm_state[8] := $01234567;
  Fptr_Fm_state[9] := $3C2D1E0F;

  Inherited Initialize();

end;

procedure TRIPEMD320.TransformBlock(a_data: PByte; a_data_length: Int32;
  a_index: Int32);
var
  data0, data1, data2, data3, data4, data5, data6, data7, data8, data9, data10,
    data11, data12, data13, data14, data15, a, b, c, d, e, aa, bb, cc, dd,
    ee: UInt32;
begin

  data0 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 0);
  data1 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 1);
  data2 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 2);
  data3 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 3);
  data4 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 4);
  data5 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 5);
  data6 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 6);
  data7 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 7);
  data8 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 8);
  data9 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 9);
  data10 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 10);
  data11 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 11);
  data12 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 12);
  data13 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 13);
  data14 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 14);
  data15 := TConverters.ConvertBytesToUInt32a2(a_data, a_index + 4 * 15);

  a := Fptr_Fm_state[0];
  b := Fptr_Fm_state[1];
  c := Fptr_Fm_state[2];
  d := Fptr_Fm_state[3];
  e := Fptr_Fm_state[4];
  aa := Fptr_Fm_state[5];
  bb := Fptr_Fm_state[6];
  cc := Fptr_Fm_state[7];
  dd := Fptr_Fm_state[8];
  ee := Fptr_Fm_state[9];

  a := a + (data0 + (b xor c xor d));
  a := TBits.RotateLeft32(a, 11) + e;
  c := TBits.RotateLeft32(c, 10);
  e := e + (data1 + (a xor b xor c));
  e := TBits.RotateLeft32(e, 14) + d;
  b := TBits.RotateLeft32(b, 10);
  d := d + (data2 + (e xor a xor b));
  d := TBits.RotateLeft32(d, 15) + c;
  a := TBits.RotateLeft32(a, 10);
  c := c + (data3 + (d xor e xor a));
  c := TBits.RotateLeft32(c, 12) + b;
  e := TBits.RotateLeft32(e, 10);
  b := b + (data4 + (c xor d xor e));
  b := TBits.RotateLeft32(b, 5) + a;
  d := TBits.RotateLeft32(d, 10);
  a := a + (data5 + (b xor c xor d));
  a := TBits.RotateLeft32(a, 8) + e;
  c := TBits.RotateLeft32(c, 10);
  e := e + (data6 + (a xor b xor c));
  e := TBits.RotateLeft32(e, 7) + d;
  b := TBits.RotateLeft32(b, 10);
  d := d + (data7 + (e xor a xor b));
  d := TBits.RotateLeft32(d, 9) + c;
  a := TBits.RotateLeft32(a, 10);
  c := c + (data8 + (d xor e xor a));
  c := TBits.RotateLeft32(c, 11) + b;
  e := TBits.RotateLeft32(e, 10);
  b := b + (data9 + (c xor d xor e));
  b := TBits.RotateLeft32(b, 13) + a;
  d := TBits.RotateLeft32(d, 10);
  a := a + (data10 + (b xor c xor d));
  a := TBits.RotateLeft32(a, 14) + e;
  c := TBits.RotateLeft32(c, 10);
  e := e + (data11 + (a xor b xor c));
  e := TBits.RotateLeft32(e, 15) + d;
  b := TBits.RotateLeft32(b, 10);
  d := d + (data12 + (e xor a xor b));
  d := TBits.RotateLeft32(d, 6) + c;
  a := TBits.RotateLeft32(a, 10);
  c := c + (data13 + (d xor e xor a));
  c := TBits.RotateLeft32(c, 7) + b;
  e := TBits.RotateLeft32(e, 10);
  b := b + (data14 + (c xor d xor e));
  b := TBits.RotateLeft32(b, 9) + a;
  d := TBits.RotateLeft32(d, 10);
  a := a + (data15 + (b xor c xor d));
  a := TBits.RotateLeft32(a, 8) + e;
  c := TBits.RotateLeft32(c, 10);

  aa := aa + (data5 + C1 + (bb xor (cc or not dd)));
  aa := TBits.RotateLeft32(aa, 8) + ee;
  cc := TBits.RotateLeft32(cc, 10);
  ee := ee + (data14 + C1 + (aa xor (bb or not cc)));
  ee := TBits.RotateLeft32(ee, 9) + dd;
  bb := TBits.RotateLeft32(bb, 10);
  dd := dd + (data7 + C1 + (ee xor (aa or not bb)));
  dd := TBits.RotateLeft32(dd, 9) + cc;
  aa := TBits.RotateLeft32(aa, 10);
  cc := cc + (data0 + C1 + (dd xor (ee or not aa)));
  cc := TBits.RotateLeft32(cc, 11) + bb;
  ee := TBits.RotateLeft32(ee, 10);
  bb := bb + (data9 + C1 + (cc xor (dd or not ee)));
  bb := TBits.RotateLeft32(bb, 13) + aa;
  dd := TBits.RotateLeft32(dd, 10);
  aa := aa + (data2 + C1 + (bb xor (cc or not dd)));
  aa := TBits.RotateLeft32(aa, 15) + ee;
  cc := TBits.RotateLeft32(cc, 10);
  ee := ee + (data11 + C1 + (aa xor (bb or not cc)));
  ee := TBits.RotateLeft32(ee, 15) + dd;
  bb := TBits.RotateLeft32(bb, 10);
  dd := dd + (data4 + C1 + (ee xor (aa or not bb)));
  dd := TBits.RotateLeft32(dd, 5) + cc;
  aa := TBits.RotateLeft32(aa, 10);
  cc := cc + (data13 + C1 + (dd xor (ee or not aa)));
  cc := TBits.RotateLeft32(cc, 7) + bb;
  ee := TBits.RotateLeft32(ee, 10);
  bb := bb + (data6 + C1 + (cc xor (dd or not ee)));
  bb := TBits.RotateLeft32(bb, 7) + aa;
  dd := TBits.RotateLeft32(dd, 10);
  aa := aa + (data15 + C1 + (bb xor (cc or not dd)));
  aa := TBits.RotateLeft32(aa, 8) + ee;
  cc := TBits.RotateLeft32(cc, 10);
  ee := ee + (data8 + C1 + (aa xor (bb or not cc)));
  ee := TBits.RotateLeft32(ee, 11) + dd;
  bb := TBits.RotateLeft32(bb, 10);
  dd := dd + (data1 + C1 + (ee xor (aa or not bb)));
  dd := TBits.RotateLeft32(dd, 14) + cc;
  aa := TBits.RotateLeft32(aa, 10);
  cc := cc + (data10 + C1 + (dd xor (ee or not aa)));
  cc := TBits.RotateLeft32(cc, 14) + bb;
  ee := TBits.RotateLeft32(ee, 10);
  bb := bb + (data3 + C1 + (cc xor (dd or not ee)));
  bb := TBits.RotateLeft32(bb, 12) + aa;
  dd := TBits.RotateLeft32(dd, 10);
  aa := aa + (data12 + C1 + (bb xor (cc or not dd)));
  aa := TBits.RotateLeft32(aa, 6) + ee;
  cc := TBits.RotateLeft32(cc, 10);

  e := e + (data7 + C2 + ((aa and b) or (not aa and c)));
  e := TBits.RotateLeft32(e, 7) + d;
  b := TBits.RotateLeft32(b, 10);
  d := d + (data4 + C2 + ((e and aa) or (not e and b)));
  d := TBits.RotateLeft32(d, 6) + c;
  aa := TBits.RotateLeft32(aa, 10);
  c := c + (data13 + C2 + ((d and e) or (not d and aa)));
  c := TBits.RotateLeft32(c, 8) + b;
  e := TBits.RotateLeft32(e, 10);
  b := b + (data1 + C2 + ((c and d) or (not c and e)));
  b := TBits.RotateLeft32(b, 13) + aa;
  d := TBits.RotateLeft32(d, 10);
  aa := aa + (data10 + C2 + ((b and c) or (not b and d)));
  aa := TBits.RotateLeft32(aa, 11) + e;
  c := TBits.RotateLeft32(c, 10);
  e := e + (data6 + C2 + ((aa and b) or (not aa and c)));
  e := TBits.RotateLeft32(e, 9) + d;
  b := TBits.RotateLeft32(b, 10);
  d := d + (data15 + C2 + ((e and aa) or (not e and b)));
  d := TBits.RotateLeft32(d, 7) + c;
  aa := TBits.RotateLeft32(aa, 10);
  c := c + (data3 + C2 + ((d and e) or (not d and aa)));
  c := TBits.RotateLeft32(c, 15) + b;
  e := TBits.RotateLeft32(e, 10);
  b := b + (data12 + C2 + ((c and d) or (not c and e)));
  b := TBits.RotateLeft32(b, 7) + aa;
  d := TBits.RotateLeft32(d, 10);
  aa := aa + (data0 + C2 + ((b and c) or (not b and d)));
  aa := TBits.RotateLeft32(aa, 12) + e;
  c := TBits.RotateLeft32(c, 10);
  e := e + (data9 + C2 + ((aa and b) or (not aa and c)));
  e := TBits.RotateLeft32(e, 15) + d;
  b := TBits.RotateLeft32(b, 10);
  d := d + (data5 + C2 + ((e and aa) or (not e and b)));
  d := TBits.RotateLeft32(d, 9) + c;
  aa := TBits.RotateLeft32(aa, 10);
  c := c + (data2 + C2 + ((d and e) or (not d and aa)));
  c := TBits.RotateLeft32(c, 11) + b;
  e := TBits.RotateLeft32(e, 10);
  b := b + (data14 + C2 + ((c and d) or (not c and e)));
  b := TBits.RotateLeft32(b, 7) + aa;
  d := TBits.RotateLeft32(d, 10);
  aa := aa + (data11 + C2 + ((b and c) or (not b and d)));
  aa := TBits.RotateLeft32(aa, 13) + e;
  c := TBits.RotateLeft32(c, 10);
  e := e + (data8 + C2 + ((aa and b) or (not aa and c)));
  e := TBits.RotateLeft32(e, 12) + d;
  b := TBits.RotateLeft32(b, 10);

  ee := ee + (data6 + C3 + ((a and cc) or (bb and not cc)));
  ee := TBits.RotateLeft32(ee, 9) + dd;
  bb := TBits.RotateLeft32(bb, 10);
  dd := dd + (data11 + C3 + ((ee and bb) or (a and not bb)));
  dd := TBits.RotateLeft32(dd, 13) + cc;
  a := TBits.RotateLeft32(a, 10);
  cc := cc + (data3 + C3 + ((dd and a) or (ee and not a)));
  cc := TBits.RotateLeft32(cc, 15) + bb;
  ee := TBits.RotateLeft32(ee, 10);
  bb := bb + (data7 + C3 + ((cc and ee) or (dd and not ee)));
  bb := TBits.RotateLeft32(bb, 7) + a;
  dd := TBits.RotateLeft32(dd, 10);
  a := a + (data0 + C3 + ((bb and dd) or (cc and not dd)));
  a := TBits.RotateLeft32(a, 12) + ee;
  cc := TBits.RotateLeft32(cc, 10);
  ee := ee + (data13 + C3 + ((a and cc) or (bb and not cc)));
  ee := TBits.RotateLeft32(ee, 8) + dd;
  bb := TBits.RotateLeft32(bb, 10);
  dd := dd + (data5 + C3 + ((ee and bb) or (a and not bb)));
  dd := TBits.RotateLeft32(dd, 9) + cc;
  a := TBits.RotateLeft32(a, 10);
  cc := cc + (data10 + C3 + ((dd and a) or (ee and not a)));
  cc := TBits.RotateLeft32(cc, 11) + bb;
  ee := TBits.RotateLeft32(ee, 10);
  bb := bb + (data14 + C3 + ((cc and ee) or (dd and not ee)));
  bb := TBits.RotateLeft32(bb, 7) + a;
  dd := TBits.RotateLeft32(dd, 10);
  a := a + (data15 + C3 + ((bb and dd) or (cc and not dd)));
  a := TBits.RotateLeft32(a, 7) + ee;
  cc := TBits.RotateLeft32(cc, 10);
  ee := ee + (data8 + C3 + ((a and cc) or (bb and not cc)));
  ee := TBits.RotateLeft32(ee, 12) + dd;
  bb := TBits.RotateLeft32(bb, 10);
  dd := dd + (data12 + C3 + ((ee and bb) or (a and not bb)));
  dd := TBits.RotateLeft32(dd, 7) + cc;
  a := TBits.RotateLeft32(a, 10);
  cc := cc + (data4 + C3 + ((dd and a) or (ee and not a)));
  cc := TBits.RotateLeft32(cc, 6) + bb;
  ee := TBits.RotateLeft32(ee, 10);
  bb := bb + (data9 + C3 + ((cc and ee) or (dd and not ee)));
  bb := TBits.RotateLeft32(bb, 15) + a;
  dd := TBits.RotateLeft32(dd, 10);
  a := a + (data1 + C3 + ((bb and dd) or (cc and not dd)));
  a := TBits.RotateLeft32(a, 13) + ee;
  cc := TBits.RotateLeft32(cc, 10);
  ee := ee + (data2 + C3 + ((a and cc) or (bb and not cc)));
  ee := TBits.RotateLeft32(ee, 11) + dd;
  bb := TBits.RotateLeft32(bb, 10);

  d := d + (data3 + C4 + ((e or not aa) xor bb));
  d := TBits.RotateLeft32(d, 11) + c;
  aa := TBits.RotateLeft32(aa, 10);
  c := c + (data10 + C4 + ((d or not e) xor aa));
  c := TBits.RotateLeft32(c, 13) + bb;
  e := TBits.RotateLeft32(e, 10);
  bb := bb + (data14 + C4 + ((c or not d) xor e));
  bb := TBits.RotateLeft32(bb, 6) + aa;
  d := TBits.RotateLeft32(d, 10);
  aa := aa + (data4 + C4 + ((bb or not c) xor d));
  aa := TBits.RotateLeft32(aa, 7) + e;
  c := TBits.RotateLeft32(c, 10);
  e := e + (data9 + C4 + ((aa or not bb) xor c));
  e := TBits.RotateLeft32(e, 14) + d;
  bb := TBits.RotateLeft32(bb, 10);
  d := d + (data15 + C4 + ((e or not aa) xor bb));
  d := TBits.RotateLeft32(d, 9) + c;
  aa := TBits.RotateLeft32(aa, 10);
  c := c + (data8 + C4 + ((d or not e) xor aa));
  c := TBits.RotateLeft32(c, 13) + bb;
  e := TBits.RotateLeft32(e, 10);
  bb := bb + (data1 + C4 + ((c or not d) xor e));
  bb := TBits.RotateLeft32(bb, 15) + aa;
  d := TBits.RotateLeft32(d, 10);
  aa := aa + (data2 + C4 + ((bb or not c) xor d));
  aa := TBits.RotateLeft32(aa, 14) + e;
  c := TBits.RotateLeft32(c, 10);
  e := e + (data7 + C4 + ((aa or not bb) xor c));
  e := TBits.RotateLeft32(e, 8) + d;
  bb := TBits.RotateLeft32(bb, 10);
  d := d + (data0 + C4 + ((e or not aa) xor bb));
  d := TBits.RotateLeft32(d, 13) + c;
  aa := TBits.RotateLeft32(aa, 10);
  c := c + (data6 + C4 + ((d or not e) xor aa));
  c := TBits.RotateLeft32(c, 6) + bb;
  e := TBits.RotateLeft32(e, 10);
  bb := bb + (data13 + C4 + ((c or not d) xor e));
  bb := TBits.RotateLeft32(bb, 5) + aa;
  d := TBits.RotateLeft32(d, 10);
  aa := aa + (data11 + C4 + ((bb or not c) xor d));
  aa := TBits.RotateLeft32(aa, 12) + e;
  c := TBits.RotateLeft32(c, 10);
  e := e + (data5 + C4 + ((aa or not bb) xor c));
  e := TBits.RotateLeft32(e, 7) + d;
  bb := TBits.RotateLeft32(bb, 10);
  d := d + (data12 + C4 + ((e or not aa) xor bb));
  d := TBits.RotateLeft32(d, 5) + c;
  aa := TBits.RotateLeft32(aa, 10);

  dd := dd + (data15 + C5 + ((ee or not a) xor b));
  dd := TBits.RotateLeft32(dd, 9) + cc;
  a := TBits.RotateLeft32(a, 10);
  cc := cc + (data5 + C5 + ((dd or not ee) xor a));
  cc := TBits.RotateLeft32(cc, 7) + b;
  ee := TBits.RotateLeft32(ee, 10);
  b := b + (data1 + C5 + ((cc or not dd) xor ee));
  b := TBits.RotateLeft32(b, 15) + a;
  dd := TBits.RotateLeft32(dd, 10);
  a := a + (data3 + C5 + ((b or not cc) xor dd));
  a := TBits.RotateLeft32(a, 11) + ee;
  cc := TBits.RotateLeft32(cc, 10);
  ee := ee + (data7 + C5 + ((a or not b) xor cc));
  ee := TBits.RotateLeft32(ee, 8) + dd;
  b := TBits.RotateLeft32(b, 10);
  dd := dd + (data14 + C5 + ((ee or not a) xor b));
  dd := TBits.RotateLeft32(dd, 6) + cc;
  a := TBits.RotateLeft32(a, 10);
  cc := cc + (data6 + C5 + ((dd or not ee) xor a));
  cc := TBits.RotateLeft32(cc, 6) + b;
  ee := TBits.RotateLeft32(ee, 10);
  b := b + (data9 + C5 + ((cc or not dd) xor ee));
  b := TBits.RotateLeft32(b, 14) + a;
  dd := TBits.RotateLeft32(dd, 10);
  a := a + (data11 + C5 + ((b or not cc) xor dd));
  a := TBits.RotateLeft32(a, 12) + ee;
  cc := TBits.RotateLeft32(cc, 10);
  ee := ee + (data8 + C5 + ((a or not b) xor cc));
  ee := TBits.RotateLeft32(ee, 13) + dd;
  b := TBits.RotateLeft32(b, 10);
  dd := dd + (data12 + C5 + ((ee or not a) xor b));
  dd := TBits.RotateLeft32(dd, 5) + cc;
  a := TBits.RotateLeft32(a, 10);
  cc := cc + (data2 + C5 + ((dd or not ee) xor a));
  cc := TBits.RotateLeft32(cc, 14) + b;
  ee := TBits.RotateLeft32(ee, 10);
  b := b + (data10 + C5 + ((cc or not dd) xor ee));
  b := TBits.RotateLeft32(b, 13) + a;
  dd := TBits.RotateLeft32(dd, 10);
  a := a + (data0 + C5 + ((b or not cc) xor dd));
  a := TBits.RotateLeft32(a, 13) + ee;
  cc := TBits.RotateLeft32(cc, 10);
  ee := ee + (data4 + C5 + ((a or not b) xor cc));
  ee := TBits.RotateLeft32(ee, 7) + dd;
  b := TBits.RotateLeft32(b, 10);
  dd := dd + (data13 + C5 + ((ee or not a) xor b));
  dd := TBits.RotateLeft32(dd, 5) + cc;
  a := TBits.RotateLeft32(a, 10);

  cc := cc + (data1 + C6 + ((d and aa) or (e and not aa)));
  cc := TBits.RotateLeft32(cc, 11) + bb;
  e := TBits.RotateLeft32(e, 10);
  bb := bb + (data9 + C6 + ((cc and e) or (d and not e)));
  bb := TBits.RotateLeft32(bb, 12) + aa;
  d := TBits.RotateLeft32(d, 10);
  aa := aa + (data11 + C6 + ((bb and d) or (cc and not d)));
  aa := TBits.RotateLeft32(aa, 14) + e;
  cc := TBits.RotateLeft32(cc, 10);
  e := e + (data10 + C6 + ((aa and cc) or (bb and not cc)));
  e := TBits.RotateLeft32(e, 15) + d;
  bb := TBits.RotateLeft32(bb, 10);
  d := d + (data0 + C6 + ((e and bb) or (aa and not bb)));
  d := TBits.RotateLeft32(d, 14) + cc;
  aa := TBits.RotateLeft32(aa, 10);
  cc := cc + (data8 + C6 + ((d and aa) or (e and not aa)));
  cc := TBits.RotateLeft32(cc, 15) + bb;
  e := TBits.RotateLeft32(e, 10);
  bb := bb + (data12 + C6 + ((cc and e) or (d and not e)));
  bb := TBits.RotateLeft32(bb, 9) + aa;
  d := TBits.RotateLeft32(d, 10);
  aa := aa + (data4 + C6 + ((bb and d) or (cc and not d)));
  aa := TBits.RotateLeft32(aa, 8) + e;
  cc := TBits.RotateLeft32(cc, 10);
  e := e + (data13 + C6 + ((aa and cc) or (bb and not cc)));
  e := TBits.RotateLeft32(e, 9) + d;
  bb := TBits.RotateLeft32(bb, 10);
  d := d + (data3 + C6 + ((e and bb) or (aa and not bb)));
  d := TBits.RotateLeft32(d, 14) + cc;
  aa := TBits.RotateLeft32(aa, 10);
  cc := cc + (data7 + C6 + ((d and aa) or (e and not aa)));
  cc := TBits.RotateLeft32(cc, 5) + bb;
  e := TBits.RotateLeft32(e, 10);
  bb := bb + (data15 + C6 + ((cc and e) or (d and not e)));
  bb := TBits.RotateLeft32(bb, 6) + aa;
  d := TBits.RotateLeft32(d, 10);
  aa := aa + (data14 + C6 + ((bb and d) or (cc and not d)));
  aa := TBits.RotateLeft32(aa, 8) + e;
  cc := TBits.RotateLeft32(cc, 10);
  e := e + (data5 + C6 + ((aa and cc) or (bb and not cc)));
  e := TBits.RotateLeft32(e, 6) + d;
  bb := TBits.RotateLeft32(bb, 10);
  d := d + (data6 + C6 + ((e and bb) or (aa and not bb)));
  d := TBits.RotateLeft32(d, 5) + cc;
  aa := TBits.RotateLeft32(aa, 10);
  cc := cc + (data2 + C6 + ((d and aa) or (e and not aa)));
  cc := TBits.RotateLeft32(cc, 12) + bb;
  e := TBits.RotateLeft32(e, 10);

  c := c + (data8 + C7 + ((dd and ee) or (not dd and a)));
  c := TBits.RotateLeft32(c, 15) + b;
  ee := TBits.RotateLeft32(ee, 10);
  b := b + (data6 + C7 + ((c and dd) or (not c and ee)));
  b := TBits.RotateLeft32(b, 5) + a;
  dd := TBits.RotateLeft32(dd, 10);
  a := a + (data4 + C7 + ((b and c) or (not b and dd)));
  a := TBits.RotateLeft32(a, 8) + ee;
  c := TBits.RotateLeft32(c, 10);
  ee := ee + (data1 + C7 + ((a and b) or (not a and c)));
  ee := TBits.RotateLeft32(ee, 11) + dd;
  b := TBits.RotateLeft32(b, 10);
  dd := dd + (data3 + C7 + ((ee and a) or (not ee and b)));
  dd := TBits.RotateLeft32(dd, 14) + c;
  a := TBits.RotateLeft32(a, 10);
  c := c + (data11 + C7 + ((dd and ee) or (not dd and a)));
  c := TBits.RotateLeft32(c, 14) + b;
  ee := TBits.RotateLeft32(ee, 10);
  b := b + (data15 + C7 + ((c and dd) or (not c and ee)));
  b := TBits.RotateLeft32(b, 6) + a;
  dd := TBits.RotateLeft32(dd, 10);
  a := a + (data0 + C7 + ((b and c) or (not b and dd)));
  a := TBits.RotateLeft32(a, 14) + ee;
  c := TBits.RotateLeft32(c, 10);
  ee := ee + (data5 + C7 + ((a and b) or (not a and c)));
  ee := TBits.RotateLeft32(ee, 6) + dd;
  b := TBits.RotateLeft32(b, 10);
  dd := dd + (data12 + C7 + ((ee and a) or (not ee and b)));
  dd := TBits.RotateLeft32(dd, 9) + c;
  a := TBits.RotateLeft32(a, 10);
  c := c + (data2 + C7 + ((dd and ee) or (not dd and a)));
  c := TBits.RotateLeft32(c, 12) + b;
  ee := TBits.RotateLeft32(ee, 10);
  b := b + (data13 + C7 + ((c and dd) or (not c and ee)));
  b := TBits.RotateLeft32(b, 9) + a;
  dd := TBits.RotateLeft32(dd, 10);
  a := a + (data9 + C7 + ((b and c) or (not b and dd)));
  a := TBits.RotateLeft32(a, 12) + ee;
  c := TBits.RotateLeft32(c, 10);
  ee := ee + (data7 + C7 + ((a and b) or (not a and c)));
  ee := TBits.RotateLeft32(ee, 5) + dd;
  b := TBits.RotateLeft32(b, 10);
  dd := dd + (data10 + C7 + ((ee and a) or (not ee and b)));
  dd := TBits.RotateLeft32(dd, 15) + c;
  a := TBits.RotateLeft32(a, 10);
  c := c + (data14 + C7 + ((dd and ee) or (not dd and a)));
  c := TBits.RotateLeft32(c, 8) + b;
  ee := TBits.RotateLeft32(ee, 10);

  bb := bb + (data4 + C8 + (cc xor (dd or not e)));
  bb := TBits.RotateLeft32(bb, 9) + aa;
  dd := TBits.RotateLeft32(dd, 10);
  aa := aa + (data0 + C8 + (bb xor (cc or not dd)));
  aa := TBits.RotateLeft32(aa, 15) + e;
  cc := TBits.RotateLeft32(cc, 10);
  e := e + (data5 + C8 + (aa xor (bb or not cc)));
  e := TBits.RotateLeft32(e, 5) + dd;
  bb := TBits.RotateLeft32(bb, 10);
  dd := dd + (data9 + C8 + (e xor (aa or not bb)));
  dd := TBits.RotateLeft32(dd, 11) + cc;
  aa := TBits.RotateLeft32(aa, 10);
  cc := cc + (data7 + C8 + (dd xor (e or not aa)));
  cc := TBits.RotateLeft32(cc, 6) + bb;
  e := TBits.RotateLeft32(e, 10);
  bb := bb + (data12 + C8 + (cc xor (dd or not e)));
  bb := TBits.RotateLeft32(bb, 8) + aa;
  dd := TBits.RotateLeft32(dd, 10);
  aa := aa + (data2 + C8 + (bb xor (cc or not dd)));
  aa := TBits.RotateLeft32(aa, 13) + e;
  cc := TBits.RotateLeft32(cc, 10);
  e := e + (data10 + C8 + (aa xor (bb or not cc)));
  e := TBits.RotateLeft32(e, 12) + dd;
  bb := TBits.RotateLeft32(bb, 10);
  dd := dd + (data14 + C8 + (e xor (aa or not bb)));
  dd := TBits.RotateLeft32(dd, 5) + cc;
  aa := TBits.RotateLeft32(aa, 10);
  cc := cc + (data1 + C8 + (dd xor (e or not aa)));
  cc := TBits.RotateLeft32(cc, 12) + bb;
  e := TBits.RotateLeft32(e, 10);
  bb := bb + (data3 + C8 + (cc xor (dd or not e)));
  bb := TBits.RotateLeft32(bb, 13) + aa;
  dd := TBits.RotateLeft32(dd, 10);
  aa := aa + (data8 + C8 + (bb xor (cc or not dd)));
  aa := TBits.RotateLeft32(aa, 14) + e;
  cc := TBits.RotateLeft32(cc, 10);
  e := e + (data11 + C8 + (aa xor (bb or not cc)));
  e := TBits.RotateLeft32(e, 11) + dd;
  bb := TBits.RotateLeft32(bb, 10);
  dd := dd + (data6 + C8 + (e xor (aa or not bb)));
  dd := TBits.RotateLeft32(dd, 8) + cc;
  aa := TBits.RotateLeft32(aa, 10);
  cc := cc + (data15 + C8 + (dd xor (e or not aa)));
  cc := TBits.RotateLeft32(cc, 5) + bb;
  e := TBits.RotateLeft32(e, 10);
  bb := bb + (data13 + C8 + (cc xor (dd or not e)));
  bb := TBits.RotateLeft32(bb, 6) + aa;
  dd := TBits.RotateLeft32(dd, 10);

  b := b + (data12 + (c xor d xor ee));
  b := TBits.RotateLeft32(b, 8) + a;
  d := TBits.RotateLeft32(d, 10);
  a := a + (data15 + (b xor c xor d));
  a := TBits.RotateLeft32(a, 5) + ee;
  c := TBits.RotateLeft32(c, 10);
  ee := ee + (data10 + (a xor b xor c));
  ee := TBits.RotateLeft32(ee, 12) + d;
  b := TBits.RotateLeft32(b, 10);
  d := d + (data4 + (ee xor a xor b));
  d := TBits.RotateLeft32(d, 9) + c;
  a := TBits.RotateLeft32(a, 10);
  c := c + (data1 + (d xor ee xor a));
  c := TBits.RotateLeft32(c, 12) + b;
  ee := TBits.RotateLeft32(ee, 10);
  b := b + (data5 + (c xor d xor ee));
  b := TBits.RotateLeft32(b, 5) + a;
  d := TBits.RotateLeft32(d, 10);
  a := a + (data8 + (b xor c xor d));
  a := TBits.RotateLeft32(a, 14) + ee;
  c := TBits.RotateLeft32(c, 10);
  ee := ee + (data7 + (a xor b xor c));
  ee := TBits.RotateLeft32(ee, 6) + d;
  b := TBits.RotateLeft32(b, 10);
  d := d + (data6 + (ee xor a xor b));
  d := TBits.RotateLeft32(d, 8) + c;
  a := TBits.RotateLeft32(a, 10);
  c := c + (data2 + (d xor ee xor a));
  c := TBits.RotateLeft32(c, 13) + b;
  ee := TBits.RotateLeft32(ee, 10);
  b := b + (data13 + (c xor d xor ee));
  b := TBits.RotateLeft32(b, 6) + a;
  d := TBits.RotateLeft32(d, 10);
  a := a + (data14 + (b xor c xor d));
  a := TBits.RotateLeft32(a, 5) + ee;
  c := TBits.RotateLeft32(c, 10);
  ee := ee + (data0 + (a xor b xor c));
  ee := TBits.RotateLeft32(ee, 15) + d;
  b := TBits.RotateLeft32(b, 10);
  d := d + (data3 + (ee xor a xor b));
  d := TBits.RotateLeft32(d, 13) + c;
  a := TBits.RotateLeft32(a, 10);
  c := c + (data9 + (d xor ee xor a));
  c := TBits.RotateLeft32(c, 11) + b;
  ee := TBits.RotateLeft32(ee, 10);
  b := b + (data11 + (c xor d xor ee));
  b := TBits.RotateLeft32(b, 11) + a;
  d := TBits.RotateLeft32(d, 10);

  Fptr_Fm_state[0] := Fptr_Fm_state[0] + aa;
  Fptr_Fm_state[1] := Fptr_Fm_state[1] + bb;
  Fptr_Fm_state[2] := Fptr_Fm_state[2] + cc;
  Fptr_Fm_state[3] := Fptr_Fm_state[3] + dd;
  Fptr_Fm_state[4] := Fptr_Fm_state[4] + ee;
  Fptr_Fm_state[5] := Fptr_Fm_state[5] + a;
  Fptr_Fm_state[6] := Fptr_Fm_state[6] + b;
  Fptr_Fm_state[7] := Fptr_Fm_state[7] + c;
  Fptr_Fm_state[8] := Fptr_Fm_state[8] + d;
  Fptr_Fm_state[9] := Fptr_Fm_state[9] + e;

end;

end.
